**MySQl(InnoDB) - マルチスレッド。ネイティブで UUID 型をサポートしていない。**

**PostgreSQL - マルチプロセス。基本はUUID v4**

**MVCC（多版型同時実行制御）**<br/> 
> 多くのデータベースシステムでは、同時実行制御のためにロック機構を使用していますが、PostgreSQLではデータ整合性の維持に多版方式を使用しています。つまり、データベースへの問い合わせ実行の際、各トランザクションは処理の基礎となっているデータの現在の状態を関知せず、現在から遡ったある時点におけるスナップショット（データベースバージョン）を参照する、というものです。これは、並行する（別の）トランザクションが同じ行を更新することによって引き起こる、整合性を欠いたデータの参照からトランザクションを保護し、個々のデータベースセッションに対してトランザクションの隔離を提供するものです。
> 多版方式とロック方式との最大の相違点は、MVCCでは問い合わせ（読み込み）ロックの獲得と、書き込みロックの獲得が競合しないことです。したがって、読み込みは書き込みを絶対にブロックしませんし、書き込みも読み込みをブロックすることがありません。
https://www.postgresql.jp/document/7.2/user/mvcc.html<br/> 
https://devcenter.heroku.com/ja/articles/postgresql-concurrency

**MVCC の欠点**<br/>
> 可視である行のセットはトランザクションごとに異なるため、Postgres では、古くなっている可能性があるレコードを維持する必要があります。UPDATE​ が実際には新しい行を作成するのはこれが理由であり、DELETE​ が実際には​行を削除せず、行を削除済みとマークして XID 値を適切に設定するだけである理由も同じです。トランザクションが完了すると、将来のどのトランザクションからも可視になる可能性がない行がデータベースに残ることになります。これらはデッドロー (dead row) と呼ばれます。MVCC に由来するもう 1 つの問題として、トランザクション ID はただ大きくなり続けることしかできません。32 ビットであり、サポートできるのは 約 40 億トランザクション “のみ"です。最大値に達すると、XID は最小値に戻って (ラップアラウンドして) ゼロから再開します。突然、すべての​行が将来のトランザクションにあるかのように見え、新しいトランザクションはそれらの行への可視性を得られなくなります。
デッドローとトランザクション XID ラップアラウンドの問題はどちらも VACUUM​ によって解決されます。これは定期的に必要なメンテナンスですが、幸いにも Postgres には、設定可能な頻度で実行される auto_vacuum デーモンが付属しています。デプロイが異なれば必要なバキューム頻度も異なるため、これを注視することは重要です。VACUUM​ の実際の動作について詳しくは、Postgres のドキュメント​を参照してください。Heroku での処理​方法も参照してください。<br/>
https://devcenter.heroku.com/ja/articles/postgresql-concurrency#disadvantages-of-mvcc

トランザクション分離レベル<br/> 
https://qiita.com/song_ss/items/38e514b05e9dabae3bdb<br/> 
https://qiita.com/PruneMazui/items/4135fcf7621869726b4b

PostgreSQLのread committed時におけるUPDATEの挙動について（ファジーリード）<br/>
https://soudai.hatenablog.com/entry/2022/07/03/223915<br/>
https://qiita.com/mpyw/items/14925c499b689a0cbc59

**Postgres と MySQL における id, created_at, updated_at に関するベストプラクティス**
> 一般的に採用されやすいプライマリキー用の値として，以下を考える。<br/>
連番整数<br/>
MySQL では AUTO_INCREMENT， Postgres では IDENTITY や SERIAL と呼ばれるもの<br/>
UUID v1: ハードウェアごとにユニークな単調増加値<br/>
UUID v4: ランダム値<br/>
UUID v7（ドラフト）: 単調増加であるタイムスタンプとランダム値の複合<br/>
https://zenn.dev/mpyw/articles/rdb-ids-and-timestamps-best-practices

PostgreSQLのガベージコレクション(vacuum)<br/>
https://www.postgresql.jp/docs/9.4/sql-vacuum.html<br/>
https://masahikosawada.github.io/2021/12/22/MVCC-and-GC-in-PostgreSQL/

----

**トランザクションとロック**

トランザクション:</br>
トランザクションは、データベース操作を一連のアクションとしてグループ化し、一貫性と完全性を維持するための重要な概念です。Railsでは、ActiveRecord::Base.transactionメソッドを使用してトランザクションを開始できます。

トランザクションが成功すると、その中で行われたすべての変更がコミットされます。何らかのエラーが発生した場合、トランザクション内の変更はロールバックされ、データベースはトランザクション開始前の状態に戻ります。

ロック:</br>
データベースロックは、データベースのリソースに対する同時アクセスを制御するための仕組みです。PostgreSQLでは、様々なロックモードがありますが、以下に主要なものを挙げます。

行レベルロック（SELECT ... FOR UPDATE / FOR NO KEY UPDATE / FOR SHARE / FOR KEY SHARE）:
行レベルロックを使用すると、特定の行に対するアクセスを制限できます。これにより、他のトランザクションがその行を変更したり、指定されたロックモードによっては読むことさえできなくなります。

テーブルレベルロック（LOCK TABLE）:
テーブル全体に対してロックをかけることができます。ただし、これは通常、他のトランザクションへの影響が大きいため、避けるべきです。

Railsでは、行レベルロックはActiveRecord::QueryMethodsのlockメソッドを使用して行うことができます。

戦略:
トランザクションとロックを適切に使用することで、データの整合性を保ちつつパフォーマンスを向上させることができます。以下にいくつかの戦略を示します。

1. トランザクションの範囲を最小限にする: トランザクション内で行われる操作は最小限に抑えることで、他のトランザクションが待たされる時間を短縮できます。これにより、システム全体のスループットが向上します。
行レベルロックを優先する: テーブル全体に対するロックは、他のトランザクションに大きな影響を与える可能性があるため、行レベルロックを使用する方が適切です。行レベルロックは、必要なリソースに対してのみ制約をかけるため、他のトランザクションが影響を受けにくくなります。

2. 適切なロックモードを選択する: PostgreSQLは様々なロックモードを提供しているため、状況に応じて適切なモードを選択することが重要です。例えば、SELECT ... FOR UPDATEは行の更新を予定している場合に適していますが、読み取り専用のアクセスが必要な場合は、SELECT ... FOR SHAREを使用する方が良いでしょう。

3. トランザクションの分離レベルを検討する: トランザクションの分離レベルは、データベースの同時実行制御の方法を決定します。PostgreSQLでは、READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLEの4つの分離レベルが提供されています。適切な分離レベルを選択することで、データ整合性を保ちながらパフォーマンスを向上させることができます。

4. インデックスを適切に使用する: データベースのインデックスは、検索性能を向上させるだけでなく、ロック競合の回避にも役立ちます。適切なインデックスを使用することで、必要なデータへのアクセスが高速化され、ロックがかかる期間が短縮されるため、トランザクションの競合を軽減できます。

これらの戦略を適切に組み合わせることで、RailsおよびPostgreSQL環境におけるデータベースのパフォーマンスと整合性を向上させることができます。

楽観ロックと悲観ロックは、データベースのリソースに対する同時アクセスを制御する2つの異なる方法です。以下にそれぞれの説明を行い、先程のトランザクションとロックの戦略との関連性を示します。

楽観ロック:
楽観ロックは、データの競合が稀であるという前提に基づいています。この方法では、データの読み取り時にロックをかけず、データを更新する際にバージョンチェックを行います。バージョンが変更されていなければ、更新を行い、そうでなければ競合が発生したと判断し、エラーを返すかリトライを行います。

Railsでは、ActiveRecord::Baseのlock_versionカラムを使用して楽観ロックを実装できます。このカラムには、レコードのバージョンが格納され、更新の度にインクリメントされます。

悲観ロック:
悲観ロックは、データの競合が頻繁に発生するという前提に基づいています。この方法では、データを読み取る際にすぐにロックをかけ、他のトランザクションがそのデータにアクセスできないようにします。これにより、データの競合を防ぐことができますが、ロックの期間が長くなると、システムのパフォーマンスに影響を与える可能性があります。

Railsで悲観ロックを実装するには、先程説明したActiveRecord::QueryMethodsのlockメソッドを使用し、SELECT ... FOR UPDATEやSELECT ... FOR SHAREなどのロックモードを指定します。

関連性:
楽観ロックと悲観ロックは、トランザクションとロックの戦略と関連しています。適切な方法を選択することで、データの整合性を保ちながらパフォーマンスを向上させることができます。

競合が少ない場合は楽観ロックを検討する: データの競合があまり発生しない状況では、楽観ロックが適切な選択肢です。これにより、不要なロックを避けることができ、システムのパフォーマンスが向上します。

1. 行ロック (悲観ロックの一例):
```ruby
class Account < ApplicationRecord
  # 残高を引き出すメソッド
  def withdraw(amount)
    # トランザクションを開始
    ActiveRecord::Base.transaction do
      # 悲観ロックを使用してアカウントをロック
      locked_account = Account.lock('FOR UPDATE').find(self.id)

      # 残高が引き出し額より多いことを確認
      if locked_account.balance >= amount
        # 残高を減らす
        locked_account.balance -= amount
        locked_account.save!
      else
        raise 'Insufficient balance'
      end
    end
  end
end
```

2. 楽観ロック:
```ruby
class Product < ApplicationRecord
  # 在庫を減らすメソッド
  def decrement_stock(quantity)
    # トランザクションを開始
    ActiveRecord::Base.transaction do
      # lock_versionカラムがあることを確認 (楽観ロックのため)
      product = Product.find(self.id)

      # 在庫が減らす数量より多いことを確認
      if product.stock >= quantity
        # 在庫を減らす
        product.stock -= quantity
        product.save! # 楽観ロックにより、競合時にActiveRecord::StaleObjectErrorが発生
      else
        raise 'Insufficient stock'
      end
    end
  rescue ActiveRecord::StaleObjectError
    # 競合が発生した場合の処理 (リトライなど)
  end
end
```

3. 悲観ロック (先述の行ロックと同じ概念ですが、読み取り専用の例を示します):
```ruby
class Report < ApplicationRecord
  # レポートのデータを読み取るメソッド
  def read_data
    data = nil

    # トランザクションを開始
    ActiveRecord::Base.transaction do
      # 悲観ロックを使用してレポートをロック (読み取り専用)
      locked_report = Report.lock('FOR SHARE').find(self.id)

      # データを読み取る処理
      data = locked_report.data
    end

    data
  end
end
```

ロック中に該当データへのアクセスが行われる場合、エラーを返すかロックが解除されるのを待つかの選択は、アプリケーションの要件とパフォーマンスへの影響に応じて決定されます。以下に、それぞれの選択が適切と考えられる例を3つずつ挙げます。

エラーを返す場合:

1. タイムリーな処理が重要な場合: 例えば、リアルタイムの株取引システムで、ロックされているデータにアクセスする際には、エラーを返し、ユーザーが別の取引を試みることができるようにする方が適切です。

2. ロック競合が頻繁に発生する場合: 競合が多い場合、ロックが解除されるのを待つと、システム全体のパフォーマンスが低下する可能性があります。そのため、エラーを返して他の処理を続行させる方が効果的です。

3. アプリケーションでリトライ機能が実装されている場合: エラーが返された場合でも、アプリケーションが自動的にリトライするように設計されている場合、エラーを返す方が適切です。

ロックが解除されるのを待つ場合:

1. データの整合性が最優先の場合: 例えば、銀行取引のように、データの整合性が非常に重要な場合、ロックが解除されるのを待って処理を完了させる方が適切です。

2. ロック競合が稀な場合: ロック競合がほとんど発生しない場合、待機時間が短く、システム全体のパフォーマンスに大きな影響を与えないため、ロックが解除されるのを待つ方が適切です。

3. ロックの期間が短い場合: ロックが短期間で解除されることが予想される場合、ロックが解除されるのを待つことで、アプリケーションの処理がスムーズに進むことが期待できます。

これらの例からも分かるように、エラーを返すかロックが解除されるのを待つかの選択は、アプリケーションの要件やデータアクセスパターン、および競合の頻度に応じて異なります。適切な選択を行うことで、アプリケーションのパフォーマンスとデータ整合性を維持することができます。実際のアプリケーション開発においては、システム全体のパフォーマンスや応答性を考慮しながら、最適な戦略を選択してください。

ECサイトの場合、悲観ロックと楽観ロックを使用する典型的なケースをそれぞれ4つずつ示します。

悲観ロックを使用するケース:

1. 在庫管理: 在庫の数量が重要で、同時に複数のユーザーが同じ商品を購入しようとする場合、悲観ロックを使用して競合を防ぎ、在庫の整合性を維持できます。

2. 注文処理: 注文処理中に他のユーザーが同時に同じアイテムを注文できないように、悲観ロックを使用して競合を回避し、注文の整合性を保つことができます。

3. 限定セール: 限定セールで競争が激しい場合、悲観ロックを使用してアイテムの整合性を保ち、同時に複数のユーザーが同じアイテムを購入できないようにします。

4. 支払い処理: 支払い情報の整合性が重要な場合、悲観ロックを使用して支払い処理中の競合を回避し、データの整合性を維持できます。

楽観ロックを使用するケース:

1. ユーザープロフィール編集: ユーザーが自分のプロフィール情報を編集する際、競合が発生する可能性は低いため、楽観ロックを使用して軽量なロック処理が実現できます。

2. 商品レビュー: ユーザーが商品に対してレビューや評価を投稿する際、楽観ロックを使用して競合を管理し、パフォーマンスの低下を防ぎます。

3. カート内アイテムの変更: ユーザーがカート内のアイテムの数量を変更する際、競合が発生する可能性が低いため、楽観ロックを使用して軽量なロック処理を実現できます。

4. お気に入りリスト管理: ユーザーがお気に入りリストに商品を追加・削除する際、競合が発生する可能性が低いため、楽観ロックを使用して効率的な処理が実現できます。

以下に、ECサイトを前提とした行ロック、楽観ロック、エラーを返す処理、およびロック解除を待つ処理の実践的なコード例を示します。この例では、商品の在庫管理を行います。

1. 行ロック (悲観ロック) とロック解除を待つ処理:
```ruby
class Product < ApplicationRecord
  def purchase(quantity)
    ActiveRecord::Base.transaction do
      # 悲観ロックを使用して商品をロック
      locked_product = Product.lock('FOR UPDATE').find(self.id)

      if locked_product.stock >= quantity
        # 在庫を減らす
        locked_product.stock -= quantity
        locked_product.save!
      else
        raise 'Insufficient stock'
      end
    end
  end
end
```

2. 楽観ロック とエラーを返す処理:
```ruby
class Product < ApplicationRecord
  def purchase(quantity)
    begin
      ActiveRecord::Base.transaction do
        product = Product.find(self.id)

        if product.stock >= quantity
          # 在庫を減らす
          product.stock -= quantity
          product.save!
        else
          raise 'Insufficient stock'
        end
      end
    rescue ActiveRecord::StaleObjectError
      # 競合が発生した場合、エラーを返す
      raise 'Conflict occurred, please try again'
    end
  end
end
```

これらのコード例は、悲観ロックと楽観ロックを使用してECサイトの商品在庫管理を行う方法を示しています。悲観ロックを使用した場合、ロックが解除されるのを待って処理が実行されます。一方、楽観ロックを使用した場合、競合が発生した際にはエラーが返され、ユーザーに再試行を促すことができます。

----

### パフォーマンスチューニング

データベースのパフォーマンスチューニングは、データベースの効率性と速度を最適化するプロセスです。これにより、アプリケーションのレスポンス時間が短縮され、リソース使用効率が向上し、システム全体のパフォーマンスが改善されます。以下に、データベースのパフォーマンスチューニングに関するいくつかの主要なポイントを示します。

1. インデックスの最適化: よく使われるクエリの検索速度を向上させるために、適切なインデックスを作成・管理することが重要です。ただし、インデックスが多すぎると、データの挿入・更新が遅くなるため、バランスを見極める必要があります。

2. クエリの最適化: クエリのパフォーマンスを向上させるために、効率的なクエリを記述することが重要です。JOINの使用を適切に制限し、WHERE句やHAVING句を利用して結果セットを絞り込むことで、パフォーマンスを向上させることができます。

3. データベース設計の見直し: データベースの設計が効率的でない場合、パフォーマンスに悪影響を与える可能性があります。正規化、非正規化、適切なデータ型の選択など、データベース設計の見直しを行い、パフォーマンスを向上させることができます。

4. ハードウェアおよびシステムの最適化: データベースサーバーのハードウェアおよびシステム設定を最適化することで、パフォーマンスを向上させることができます。メモリ、ストレージ、CPU、ネットワークなどのリソースを適切に割り当て、データベース管理システム(DBMS)の設定を調整して、パフォーマンスを最適化します。

5. キャッシュとバッファの利用: データベースの設定を調整して、キャッシュのサイズやバッファプールのサイズを最適化します。これにより、頻繁にアクセスされるデータや実行されるクエリを効率的に処理できるようになります。

6. パーティショニング: 大量のデータを扱う場合、パーティショニングを利用してデータを複数の小さなテーブルに分割することで、パフォーマンスを向上させることができます。パーティショニングにより、クエリの対象となるデータ量が減少し、検索速度が向上します。

7. データベースの監視と分析: データベースのパフォーマンスを継続的に監視し、ボトルネックや遅延を特定することが重要です。パフォーマンス監視ツールを活用して、データベースの動作状況を詳細に把握し、問題の特定と解決に役立てます。

8. バージョンアップとパッチ適用: データベース管理システム(DBMS)の最新バージョンやパッチを適用することで、パフォーマンスの向上やセキュリティの強化が図られます。定期的にDBMSのアップデートを行い、新機能やパフォーマンス改善を活用します。

9. 負荷分散とスケーリング: 負荷分散を実現するために、リードレプリカを使用して読み取りクエリの負荷を分散させることができます。また、システムのスケーラビリティを向上させるために、垂直スケーリング（リソースの追加）や水平スケーリング（ノードの追加）を検討することが重要です。

データベースのパフォーマンスチューニングは、これらの手法を組み合わせて適用することで、効果的な結果を得ることができます。各企業やアプリケーションの要件に応じて、適切なチューニング手法を選択し、継続的にパフォーマンスを最適化していくことが重要です。

1. インデックスの最適化
実務に即した例:
あるECサイトを運営しているとしましょう。RailsアプリケーションでPostgreSQLデータベースを使用しており、商品テーブル（products）があります。顧客が商品を検索する際、商品名やカテゴリでの検索が一般的です。そのため、これらのカラムにインデックスを作成して、検索速度を向上させることが重要です。

実践方法:

1.1. 適切なインデックスの作成
以下のようなRailsのマイグレーションファイルを作成し、商品名（name）とカテゴリ（category_id）にインデックスを作成します。
```ruby
class AddIndexToProducts < ActiveRecord::Migration[6.1]
  def change
    add_index :products, :name
    add_index :products, :category_id
  end
end
```
1.2. インデックスの使用状況の確認
PostgreSQLでは、pg_stat_user_indexesビューを使ってインデックスの使用状況を確認できます。以下のSQLクエリでインデックスの使用状況を確認できます。
```sql
SELECT
  relname AS table_name,
  indexrelname AS index_name,
  idx_scan AS times_used,
  pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM
  pg_stat_user_indexes
JOIN
  pg_index USING (indexrelid)
WHERE
  schemaname = 'public'
ORDER BY
  times_used DESC;
```

1.3. 不要なインデックスの削除
上記のクエリで、使用されていないインデックスや冗長なインデックスが見つかった場合、それらを削除することでパフォーマンスを向上させることができます。Railsのマイグレーションファイルを作成し、不要なインデックスを削除します。
```ruby
class RemoveUnusedIndexes < ActiveRecord::Migration[6.1]
  def change
    remove_index :products, :old_column_name
  end
end
```

インデックスの最適化は、アプリケーションのパフォーマンスを大幅に向上させることができますが、同時に適切なインデックスの選択や管理が重要です。AWS RDS for PostgreSQLを使用している場合、RDSの機能を活用してインデックスの管理やパフォーマンス監視を行うことができます。また、Sentryを使ってアプリケーションのエラー監視やパフォーマンス分析を行い、インデックスの最適化による効果を評価することができます。Sentryのパフォーマンスモニタリング機能を使って、データベースクエリの応答時間やエラー率を監視し、インデックスの最適化が効果的に機能しているかを確認できます。インデックスの最適化により、データベースクエリの応答時間が短縮され、アプリケーション全体のパフォーマンスが改善されることが期待されます。

最適なインデックス戦略を維持するために、アプリケーションの要件やデータアクセスパターンが変化した際には、インデックスの見直しを定期的に行ってください。また、インデックスの選択や管理についてチーム全体で知識を共有し、データベースのパフォーマンス向上に取り組むことが重要です。


-----
