### Railsのアプリケーションサーバーのプロセス数とスレッド数の設定方法

https://tech-book.precena.co.jp/software/backend/ruby-on-rails/rails-process-and-thread

----
### スレッド数をあまり増やしても効果がない理由

> MRI（CRuby）の場合、IO待ち（データベースの結果待ちなど）だけが並列化可能です。これは多くのWebアプリでおそらく総時間の10〜25%を占めるでしょう。自分のアプリで、リクエストごとにデータベースで使われる総時間をチェックできます。残念なことに、アムダールの法則によれば、並列性の占める割合が小さい（50%未満）の場合、手頃なスレッド数をさらに増やすメリットはほとんど（あるいはまったく）ありません。そしてこのことは私の経験とも整合します。Noah GibbsもDiscourseホームページのベンチマークでこれをテストした結果、スレッド数は6に落ち着いたそうです。

https://techracho.bpsinc.jp/hachi8833/2022_06_14/47696

----

### mallocでマルチスレッドプログラムのメモリが倍増する理由

> Rubyがメモリ使用量の少ない言語であることは、意外に知られていません。しかしRailsアプリの多くは1プロセスあたりのメモリ使用量が1 GBに達する問題に悩まされています。これはJavaレベルに匹敵しつつあります。Rubyのバックグラウンドジョブプロセッサとして有名なSidekiqのプロセスも、同程度かそれより巨大になることがあります。理由はいろいろありますが、特に、断片化の診断とデバッグが極端に難しいこともそのひとつです。

> しかしRubyプログラムのメモリ使用量は、断片化によって通常の「倍」に、場合によっては4倍以上に達することすらあるのです！

> さらに厄介なのは、メモリが4つの異なる層によって抽象化され、Rubyistから見えなくなっていることです。第1層はRubyの仮想マシン（VM）そのものです。VMは独自の内部構造やメモリトラッキング機能を備えています（これはObjectSpaceと呼ばれることもあります）。第2層はアロケータです。この振る舞いは、用いる特定の実装によって大きく異なります。第3層はOSです。ここでは実際の物理メモリアドレスを仮想メモリアドレスに抽象化します。この抽象化はカーネルごとに大きく異なっています。たとえばMachの抽象化はLinuxとかなり異なります。最後の第4層は実際のハードウェアそのものです。ここでは、アクセスの多いデータが、頻繁にアクセスしやすい「ホット」な場所からなるべく移動しないようにするためにさまざまな戦略を用います。ときには、translation lookaside buffer（TLB）のような特殊なCPU部品まで関わっていることがあります。

> ほとんどのメモリ断片化（およびアロケーション）はObjectSpaceの中では起きていないのです。断片化が発生するのは、1個のRVALUEに収まりきれないオブジェクトに空き（メモリ）を割り当てるときです。Aaron PattersonとSam Saffronによる実験結果によると、ほとんどがこれに該当することが判明しました。典型的なRailsアプリのメモリ使用量の50%〜80%は、たかが数バイトより大きなオブジェクトに空きメモリを割り当てるmalloc呼び出しによって占められています。

> メモリ断片化は、本質的には（数学の）ビンパッキング問題（bin packing problem）です。変な形のピースをいくつもの容器（bin）に振り分けて、隙間を最小にするにはどうしたらよいでしょうか。次の理由から、ビンパッキング問題によってアロケータの難易度が非常に高まります。a）Rubyではメモリ上の場所を決して移動できない（場所をいったん割り当てると、オブジェクトやデータは解放されるまでそこにとどまる）。b）スレッド単位メモリアリーナは、本質的には容器を大量に作成しますが、これらを結合したりまとめたりすることができません。ビンパッキング問題は既にNP困難であり、この制約があるために最適解を得るのがさらに難しくなってしまいます。

> 利用可能なメモリアリーナの個数を減らすと、断片化を軽減できるのです。この方法には明確なトレードオフが存在します。アリーナを減らせばメモリ使用量を減らせますが、その代わりロックの競合が増加してプログラムの実行速度が落ちる可能性があります。
> 基本的に、メモリアリーナのデフォルトの振る舞いはlibc 2.19で実行時間が10%削減されましたが、メモリ使用量は75%も増加したのです！メモリアリーナの最大数を2まで減らすと、スピードアップは得られない代わりに、旧Ceder-10スタックと比較して10%（デフォルトのメモリアリーナの振る舞いと比較すればほぼ2倍！）もメモリ使用量が削減されたのです。ほとんどすべてのRubyアプリにとって、メモリ使用量を75%増やすのと引き換えに10%スピードアップするというのは、割に合わないトレードオフです。

問題の修正方法：
> jemallocもスレッド単位アリーナを実装していますが、mallocで起きる断片化を回避する設計になっているようです。
> jemallocをRubyで使うときに押さえておきたい点を以下に示します。
Herokuならこのbuildpackでjemallocを使えます。
jemalloc 4.xはRubyで使ってはいけません。LinuxのTransparent Huge Pages（THP）との相性が悪く、表示されるメモリ節約量が目減りしてしまいます。使うならjemalloc 3.6にしましょう。なお、5.0でRubyのパフォーマンスがどう変わるかは不明です。
Rubyをjemalloc付きでコンパイルする必要はありません（一応可能ですが）。LD_PRELOADを使えば動的に読み込めます。


https://techracho.bpsinc.jp/hachi8833/2022_06_23/50109

----

### 非同期I/O

非同期I/Oとは、入出力処理を行う際に、アプリケーションがブロックされることなく、他のタスクを並行して実行できるようにするI/O処理の方法です。通常の同期I/Oでは、データの読み書きが完了するまでアプリケーションが待機し、その間他のタスクを実行できません。非同期I/Oでは、I/O操作が完了するまでの間に、アプリケーションが他のタスクを実行し、I/O操作が完了したら結果を受け取る仕組みが提供されます。

非同期I/Oは以下のようなメリットがあります。

1. パフォーマンス向上: 入出力操作が他のタスクと並行して実行できるため、全体的なアプリケーションのパフォーマンスが向上します。

2. リソースの効率的な利用: 非同期I/Oを利用することで、CPUやメモリリソースを効率的に活用できます。入出力待ちの間に他のタスクを実行できるため、リソースのアイドル時間が減り、システム全体の効率が向上します。

3. スケーラビリティの向上: 非同期I/Oは、多数の同時接続やリクエストを効率的に処理できるため、アプリケーションのスケーラビリティが向上します。

非同期I/Oを実現する方法はいくつかあります。以下に、主な方法をいくつか紹介します。

1. コールバック関数: I/O操作が完了した際に実行されるコールバック関数を登録し、I/O操作の完了を非同期的に通知する方法です。

2. イベントループ: イベントループは、アプリケーションが非同期I/O操作の完了イベントをポーリングし、適切な処理を実行するための仕組みです。Node.jsのようなイベントループをベースにしたプラットフォームでは、この方法が一般的です。

3. プロミス（Promise）: 非同期処理の結果を表現するオブジェクトで、成功時や失敗時に実行されるコールバック関数を登録できます。JavaScriptやPythonのasync/awaitなどの言語機能は、プロミスを利用して非同期I/Oを実現しています。

4. 非同期I/O用API: オペレーティングシステムが提供する非同期I/O用のAPIを利用する方法です。例えば、Linuxではepoll、macOSやFreeBSDではkqueue、WindowsではIOCP（I/O Completion Ports）などが提供されています。これらのAPIを使用することで、アプリケーションはI/O操作を効率的に並行して処理できます。

5. スレッドやタスクの並列化: スレッドや軽量なタスク（コルーチンやグリーンスレッドなど）を利用して、非同期I/O操作を並行して実行する方法です。この方法では、各スレッドやタスクが独立したI/O操作を行い、全体として非同期的にI/O処理が実行されます。

Ruby言語では、以下のような方法で非同期I/Oを実現できます。

1. IO.select: 複数のI/Oオブジェクト（ソケットやファイルディスクリプタなど）の読み込みや書き込みの準備ができたものを効率的に待ち受けるためのメソッドです。これを利用して、アプリケーションがブロックされることなく複数のI/O操作を並行して処理できます。

2. IO#nonblock: RubyのIOクラスには、非ブロッキングモードでのI/O操作をサポートするメソッドがいくつか用意されています。IO#nonblock_readやIO#nonblock_writeなどのメソッドを使用することで、非同期I/Oを実現できます。

3. Rubyのスレッド: Rubyでは、スレッドを利用してI/O操作を並行して実行することができます。Threadクラスを使用して、複数のスレッドを作成し、それぞれで非同期I/O操作を行うことができます。

4. イベントループライブラリ: Rubyでは、イベントループを利用した非同期I/Oを実現するためのライブラリがいくつかあります。例えば、EventMachineやCelluloid::IOなどのライブラリを使用することで、効率的な非同期I/O処理を実現できます。

----
