### JWTとは
> JWTはHTTPヘッダーで利用することを前提としたJSONの表現方法を定めているだけで、セキュリティについてはなにも考慮していません。データは単にBase64URLエンコードしているだけで、Base64URLデコードすることで簡単に内容を見ること(盗聴)ができます。また、デコードしたデータを修正してエンコードし直すことで簡単にデータを改ざんすることもできます。このため、JWT単独で重要なデータを扱うには問題があります。
このJWTの改ざんを防止する手段としてJSON Web Signature(JWS)[1]があります。ただし、改ざん防止といってもデータを改ざんできないようにするのではなく、JWSはデータが改ざんされたらそれを検知する仕組み、もっというと受け取ったJWTが本物かどうかを確認する仕組みとなります。

> JWSの署名<br/>
改ざん防止で登場するのが暗号鍵を使ったデータの署名です。
暗号鍵を使ったJWTの署名は次の図をもとに説明します。なお、説明は理解を容易にするため、暗号化する側と復号化する側の双方が同じ鍵を使う共通鍵方式(秘密鍵方式)を前提にしています。公開鍵方式の説明は共通鍵で全体の仕組みを解説した後に簡単に行います。

> - クレーム(claim)<br/>
JSONのデータ項目をJWTのコンテキストで説明するときの用語。実体としてはJSONのデータ項目と同じ
複数のクレーム集合をクレームセットといい、これがJSONデータの全体に相当する
> - JWT(JSON Web Token)<br/>
JWSによりエンコードされたクレームセット<br/>
言い方を変えるとJWSのペイロードになるものがJWTともいえる<br/>
> - JWSコンパクトシリアライゼーション<br/>
ヘッダーとペイロード(JWT)とシグニチャをBASE64URLエンコードして.(ドット)で連結すること<br/>
> - JWS(JSON Web Signature)<br/>
JWTをJWSコンパクトシリアライゼーションしたもの<br/>
つまりJWSとはJWSコンパクトシリアライゼーションした次の文字列を指すBASE64URLエンコード(ヘッダー) + . + BASE64URLエンコード(ペイロード) + . + BASE64URLエンコード(シグニチャ)

> RFC的にJWSのデータ部に相当するものをJWTと呼ぶ定義となっているため、JWTとJWSは相互に依存した概念[4]となっています。このため、JWTやJWSの説明が難しくなっていますが、実際のところ、JWTはJSONの表現形式で、そのJWTをセキュアにやり取りできるようにJWSシリアライゼーションした文字列がJWSと理解して困ることはありません。
また、JWTはJWSの部分に対する呼び方のため、概念としてJWTが単独で存在することはありませんが、一般的にJWSのことをJWTとして呼んでいることも多くあります。ですので、次のJWTによる認証では一般的な呼び方にならいJWSはJWTとして説明します。

> JWT認証とは認証情報が設定されたJWTをもとにユーザ認証を行うことです。
もっと、平たくいうと、ユーザの認証方式として、自身のIDとそのユーザしか知り得ないパスワードを提示ししてもらうことでそのユーザが確かにIDに対する本人であることを識別するユーザログインが一般的ですが、JWT認証はIDとパスワードの代わりに自身が信頼していているアプリが発行した認証情報のJWTを提示してもらい、そのJWTを信頼したアプリと取り交わした鍵情報で検証することで、JWTに書かれているユーザ本人だと確認することとなります。

> JWEはJWT全体を暗号化して中身を見られなくする技術です。JWEを理解するにはその元データとなるJWTや関連するJWSへの理解が必要です。また、OpenIDConnectやOAuth2.0は主にアプリがIDプロバイダーからJWTのIDトークンを取得するまでの一連の流れを規定しているものとなります。よって、今回のベーシックなJWT認証の仕組みに対する理解なくしてOpenIDConnectやOAuth2.0の理解はおぼつきません。

https://developer.mamezou-tech.com/blogs/2022/12/08/jwt-auth/

https://www.logicmonitor.jp/blog/what-are-json-web-tokens

https://qiita.com/doyaaaaaken/items/02357c2ebca994160804

> WebアプリケーションでJWTをセッションに使う際の保存先は（自分なりに説明できれば）どちらでもよいと思います
> CookieだろうがlocalstorageだろうがどっちもXSSの前には無力です

> - CookieはJWTが漏れないだけで攻撃ができないわけではない<br/>
>   - リクエストを投げればブラウザが勝手につけるので、XSSで目的のリクエストを投げればいいので無力<br/>
> - localstorageはJWTも漏れるし、Cookieと同様にリクエストを投げるロジックを呼べばよい<br/>
>   - こっちはブラウザが勝手につけるわけではないが、XSSできるなら取得してリクエストにつけて投げるのも簡単なので無力<br/>
とはいえ、Cookie(httponly)ならJavaScriptからどうあがいても読み取ることはできません。 そういった意味ではlocalstorageよりもCookieのほうがセキュアかもしれません。ただしhttponlyなCookieだろうがXSSで攻撃に繋げられるのであまり意味はないこともあります。

> 「ランダムなセッションID」はセッションIDだけ見ても情報はわかりません。しかし、そこからサーバサイドに問い合わせてどういうユーザか等の情報を集めるということはできます。<br/>
一方、JWTはペイロードの内容から情報を抜き取ることができます。JWTをみれば誰がいつログインしたかとかの情報はわかってしまうかもしれません（持たせている情報によります） では暗号化しましょう、とJWE を採用するとか、独自にペイロード部分を暗号化するのもよいでしょうが、そこまでする価値はあるかというと、私は無いと思います。 ランダムなセッションIDを使った場合と同じで、結局サーバサイドに問い合わせてどういうユーザか等の情報を集めるということはできるからです。

> Chatworkさんの事例<br/>
> Chatworkさんの事例ではアクセストークンをステートレスで扱います。その代わり、期限を30分と短くしてその期限内の悪用は許容しています。 で、使い続けたい場合はリフレッシュトークンでアクセストークンを作り直してくれ、というやり方です。そこにログアウトはないということです。 その代わり再発行するためのリフレッシュトークンは結局ユーザに紐づけて管理しています。まぁ、ここを管理しないといくらでも再発行できちゃうor都度アクセストークンを発行させるような作業をユーザに強いることになりますからね。<br/>
これは頭が良くて、よく「セッション情報が流出したから強制ログアウトさせたい」みたいな運用を求めることがありますが、この運用自体が手遅れなんです。流出した事実はかわらないですからね。 パスワードのハッシュが流出したんでパスワードを再設定してください、というのも手遅れ。GitHubにAWSのアクセスキー流しちゃったとかも手遅れ。流出した事実はかわらないですからね。<br/>
そこで、流出したものが無意味になればどうでしょうか。パスワードのハッシュならハッシュに使うsalt値を変えれば概ね無意味になりますし、AWSのアクセスキーとかは失効できます。


https://ryozi.hatenadiary.jp/entry/2022/02/12/073014

https://twitter.com/ockeghem/status/1492786731607019523

----
